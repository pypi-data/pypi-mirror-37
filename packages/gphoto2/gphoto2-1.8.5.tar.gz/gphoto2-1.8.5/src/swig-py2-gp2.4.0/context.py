# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _context.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_context')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_context')
    _context = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_context', [dirname(__file__)])
        except ImportError:
            import _context
            return _context
        try:
            _mod = imp.load_module('_context', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _context = swig_import_helper()
    del swig_import_helper
else:
    import _context
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import gphoto2.abilities_list
import gphoto2.camera
import gphoto2.file
import gphoto2.filesys
import gphoto2.list
import gphoto2.port_info_list
import gphoto2.port_log
import gphoto2.result
import gphoto2.version
import gphoto2.widget
class Context(object):
    """Proxy of C _GPContext struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(_GPContext self) -> Context"""
        _context.Context_swiginit(self, _context.new_Context())
    __swig_destroy__ = _context.delete_Context
Context_swigregister = _context.Context_swigregister
Context_swigregister(Context)


def gp_context_new():
    """
    gp_context_new() -> Context

    Creates a new context.  

    To be used by the frontend.  

    Returns
    -------
    a GPContext.
    """
    return _context.gp_context_new()
GP_CONTEXT_FEEDBACK_OK = _context.GP_CONTEXT_FEEDBACK_OK
GP_CONTEXT_FEEDBACK_CANCEL = _context.GP_CONTEXT_FEEDBACK_CANCEL

def gp_context_set_idle_func(context, func, data):
    """gp_context_set_idle_func(Context context, GPContextIdleFunc func, void * data)"""
    return _context.gp_context_set_idle_func(context, func, data)

def gp_context_set_progress_funcs(context, start_func, update_func, stop_func, data):
    """gp_context_set_progress_funcs(Context context, GPContextProgressStartFunc start_func, GPContextProgressUpdateFunc update_func, GPContextProgressStopFunc stop_func, void * data)"""
    return _context.gp_context_set_progress_funcs(context, start_func, update_func, stop_func, data)

def gp_context_set_error_func(context, func, data):
    """gp_context_set_error_func(Context context, GPContextErrorFunc func, void * data)"""
    return _context.gp_context_set_error_func(context, func, data)

def gp_context_set_status_func(context, func, data):
    """gp_context_set_status_func(Context context, GPContextStatusFunc func, void * data)"""
    return _context.gp_context_set_status_func(context, func, data)

def gp_context_set_question_func(context, func, data):
    """gp_context_set_question_func(Context context, GPContextQuestionFunc func, void * data)"""
    return _context.gp_context_set_question_func(context, func, data)

def gp_context_set_cancel_func(context, func, data):
    """gp_context_set_cancel_func(Context context, GPContextCancelFunc func, void * data)"""
    return _context.gp_context_set_cancel_func(context, func, data)

def gp_context_set_message_func(context, func, data):
    """gp_context_set_message_func(Context context, GPContextMessageFunc func, void * data)"""
    return _context.gp_context_set_message_func(context, func, data)

def gp_context_idle(context):
    """
    gp_context_idle(Context context)

    Notify frontend of a brief idle time.  

    Tells the frontend that it can do other processing at this moment, like
    refresh the UI. Backends should call this function every time when an
    interruption of the transfer is possible.  

    Parameters
    ----------
    * `context` :  
        a GPContext
    """
    return _context.gp_context_idle(context)

def gp_context_error(context, format):
    """gp_context_error(Context context, char const * format)"""
    return _context.gp_context_error(context, format)

def gp_context_status(context, format):
    """gp_context_status(Context context, char const * format)"""
    return _context.gp_context_status(context, format)

def gp_context_message(context, format):
    """
    gp_context_message(Context context, char const * format)

    Print a message to the context.  

    This sends a message to the passed context, to be printed by it in some
    kind of way, but do no other action.  

    To be used by camera drivers.  

    Parameters
    ----------
    * `context` :  
        A GPContext  
    * `format` :  
        A sprintf style format string  
    * `...` :  
        variable argument list depending on format string
    """
    return _context.gp_context_message(context, format)

def gp_context_question(context, format):
    """
    gp_context_question(Context context, char const * format) -> GPContextFeedback

    Ask frontend user a question.  

    Asks the user a question that he must answer either with "Ok" or
    "Cancel".  

    To be used by a camera driver. (So far no camera driver is using it, but
    this might change later.)  

    Parameters
    ----------
    * `context` :  
        a GPContext  
    * `format` :  
        a sprintf format string  
    * `...` :  
        variable arguments for format string  

    Returns
    -------
    The user's answer in form of a GPContextFeedback.
    """
    return _context.gp_context_question(context, format)

def gp_context_cancel(context):
    """
    gp_context_cancel(Context context) -> GPContextFeedback

    gp_context_cancel: : a GPContext  

    Gives the frontend the possibility to cancel the current operation that
    is executed in this .  

    Return value: a GPContextFeedback.
    """
    return _context.gp_context_cancel(context)

def gp_context_progress_start(context, target, format):
    """
    gp_context_progress_start(Context context, float target, char const * format) -> unsigned int

    Start progress tracking.  

    This function starts up a new progress tracking for a specified context.
    Several nested progress reports can happen at once, depending on the
    backend.  

    Parameters
    ----------
    * `context` :  
        The context in which to start the progress.  
    * `target` :  
        The 100% value.  
    * `format` :  
        A sprintf style string to print out, including the following
        variable arguments.
    """
    return _context.gp_context_progress_start(context, target, format)

def gp_context_progress_update(context, id, current):
    """gp_context_progress_update(Context context, unsigned int id, float current)"""
    return _context.gp_context_progress_update(context, id, current)

def gp_context_progress_stop(context, id):
    """gp_context_progress_stop(Context context, unsigned int id)"""
    return _context.gp_context_progress_stop(context, id)


