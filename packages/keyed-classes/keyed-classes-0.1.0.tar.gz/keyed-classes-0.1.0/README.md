# keyed-classes

Create pseudo-singleton key based objects like those generated by `logging.getLogger`

```python
>>> from keyed_classes import KeyedClass
>>> class MyClass(KeyedClass)
...     def __init__(self, key):
...         self.key = key
...
>>> instance_one = MyClass('this is a key')
>>> instance_two = MyClass('this is a key')
>>> instance_three = MyClass('this is a different key')
>>> instance_one is instance_two
True
>>> instance_one is instance_three
False
```

*Note*: Some thought needs to be put into the `__init__` method of a `KeyedClass`. If attempting to create a new instance may or may not just return a previously created instance instead, what does that mean for code in `__init__`, and instance variables (and whatever else) created there-in?

This is getting a bit implementation detail-y, but in every time you try to create a new instance the code in `__init__` will be run, `self` either referring to the newly created instance if the key did not previously exist, and referring to the original instance created from the key if it has been used before.

---

If you'd like to avoid subclassing `KeyedClass` but still want something like this for whatever reason, there is also a metaclass version `keyed_classes.KeyedClassMeta`, but I would recommend against using it, as it's not quite as friendly as `keyed_classes.KeyedClass`.

```python
>>> from keyed_classes import KeyedClassMeta
>>> class MyClass(metaclass=KeyedClassMeta)
...     def __init__(self, key):
...         self.key = key
...
>>> instance_one = MyClass('this is a key')
>>> instance_two = MyClass('this is a key')
>>> instance_three = MyClass('this is a different key')
>>> instance_one is instance_two
True
>>> instance_one is instance_three
False
```

*Note*: The behavior is not exactly the same between the two implementations. `keyed_classes.KeyedClassMeta` classes actually do create a new instance every time one is requested (and the `__init__` method is run on this new instance), but this object is essentially just thrown away before it gets back to the user and the originally created object is returned back to the user.

## Why do I want this?

You probably don't!

Generally this is a bit of a cludgy solution, it is effectivly just cleverly using (and hiding from the user) global state, which we all know is something approximating the root of all evil.

I came up with this as a solution to the issue of mutually exclusive groups of options in [`Click`](https://click.palletsprojects.com/en/7.x/), which does not support that feature itself.

```python
import click
from keyed_classes import KeyedClass

class MutuallyExclusiveOptionGroup(KeyedClass):
    def __init__(self, key):
        self.key = key
        self.tripped = False

    def __call__(self, ctx, param, value):
        if value is None:
            return

        if self.tripped:
            op, _ = self.option
            raise click.BadParameter(f"'{op.name}' already specified, only one '{self.key}' option allowed in one invocation.")
        else:
            self.tripped = True
            self.option = (param, value)
        return value


@click.command()
@click.option("--op1", callback=MutuallyExclusiveOptionGroup('method'))
@click.option("--op2", callback=MutuallyExclusiveOptionGroup('method'))
...
def main(op1, op2, ...):
    ...
```
