# -*- coding: utf-8 -*-
from distutils.core import setup

packages = \
['keyed_classes']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'keyed-classes',
    'version': '0.1.0',
    'description': 'Create pseudo-singleton key based objects like those generated by logging.getLogger',
    'long_description': '# keyed-classes\n\nCreate pseudo-singleton key based objects like those generated by `logging.getLogger`\n\n```python\n>>> from keyed_classes import KeyedClass\n>>> class MyClass(KeyedClass)\n...     def __init__(self, key):\n...         self.key = key\n...\n>>> instance_one = MyClass(\'this is a key\')\n>>> instance_two = MyClass(\'this is a key\')\n>>> instance_three = MyClass(\'this is a different key\')\n>>> instance_one is instance_two\nTrue\n>>> instance_one is instance_three\nFalse\n```\n\n*Note*: Some thought needs to be put into the `__init__` method of a `KeyedClass`. If attempting to create a new instance may or may not just return a previously created instance instead, what does that mean for code in `__init__`, and instance variables (and whatever else) created there-in?\n\nThis is getting a bit implementation detail-y, but in every time you try to create a new instance the code in `__init__` will be run, `self` either referring to the newly created instance if the key did not previously exist, and referring to the original instance created from the key if it has been used before.\n\n---\n\nIf you\'d like to avoid subclassing `KeyedClass` but still want something like this for whatever reason, there is also a metaclass version `keyed_classes.KeyedClassMeta`, but I would recommend against using it, as it\'s not quite as friendly as `keyed_classes.KeyedClass`.\n\n```python\n>>> from keyed_classes import KeyedClassMeta\n>>> class MyClass(metaclass=KeyedClassMeta)\n...     def __init__(self, key):\n...         self.key = key\n...\n>>> instance_one = MyClass(\'this is a key\')\n>>> instance_two = MyClass(\'this is a key\')\n>>> instance_three = MyClass(\'this is a different key\')\n>>> instance_one is instance_two\nTrue\n>>> instance_one is instance_three\nFalse\n```\n\n*Note*: The behavior is not exactly the same between the two implementations. `keyed_classes.KeyedClassMeta` classes actually do create a new instance every time one is requested (and the `__init__` method is run on this new instance), but this object is essentially just thrown away before it gets back to the user and the originally created object is returned back to the user.\n\n## Why do I want this?\n\nYou probably don\'t!\n\nGenerally this is a bit of a cludgy solution, it is effectivly just cleverly using (and hiding from the user) global state, which we all know is something approximating the root of all evil.\n\nI came up with this as a solution to the issue of mutually exclusive groups of options in [`Click`](https://click.palletsprojects.com/en/7.x/), which does not support that feature itself.\n\n```python\nimport click\nfrom keyed_classes import KeyedClass\n\nclass MutuallyExclusiveOptionGroup(KeyedClass):\n    def __init__(self, key):\n        self.key = key\n        self.tripped = False\n\n    def __call__(self, ctx, param, value):\n        if value is None:\n            return\n\n        if self.tripped:\n            op, _ = self.option\n            raise click.BadParameter(f"\'{op.name}\' already specified, only one \'{self.key}\' option allowed in one invocation.")\n        else:\n            self.tripped = True\n            self.option = (param, value)\n        return value\n\n\n@click.command()\n@click.option("--op1", callback=MutuallyExclusiveOptionGroup(\'method\'))\n@click.option("--op2", callback=MutuallyExclusiveOptionGroup(\'method\'))\n...\ndef main(op1, op2, ...):\n    ...\n```\n',
    'author': 'David Buckley',
    'author_email': 'buckley.w.david@gmail.com',
    'url': 'https://github.com/buckley-w-david/keyed-classes/',
    'packages': packages,
    'package_data': package_data,
}


setup(**setup_kwargs)
