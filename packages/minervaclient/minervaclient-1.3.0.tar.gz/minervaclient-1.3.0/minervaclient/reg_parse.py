from __future__ import print_function
from __future__ import absolute_import
from __future__ import unicode_literals
from future import standard_library # TODO: why future import standard_library shows error on pylinter (py3)
standard_library.install_aliases()
from builtins import str
# reg_parse.py: Interpret results and errors from the Quick Add/Drop interface
# This file is from Minervac, a command-line client for Minerva
# <http://npaun.ca/projects/minervac>
# (C) Copyright 2016-2017 Nicholas Paun

from bs4 import BeautifulSoup
import urllib.request, urllib.parse, urllib.error
import sys
import codecs
from .minerva_common import *

html_parser = 'html5lib'
try:
    import html5lib
except ImportError:
    html_parser = 'html.parser'

def quick_add_insert(text,crns):
    html = BeautifulSoup(text, html_parser)
    forms = html.body.find_all('form')

    reg = forms[1]
    inputs = reg.find_all(['input','select'])
    request = []


    for input in inputs:
        
        if not input.has_attr('name'):
            if input.has_attr('id'):
                print("A problem occurred:")
            else:
                continue

        
        if input.has_attr('value'): #This should always fail for a select.
            val = input['value']
        else:
            val = ''

        if val == 'Class Search':  #We want to register and not search,
            continue
            if crns and input['name'] == 'CRN_IN' and val == '':  # Shove our CRN in the first blank field
                val = crns.pop(0)
        try:
            request.append((input['name'], val))
        except KeyError:
            sys.exit(quick_add_issue("Wrong McGill ID or password."))
    
    
    return urllib.parse.urlencode(request)

def quick_add_status(text):
    html = BeautifulSoup(text, html_parser)
    errtable = html.body.find('table',{'summary':'This layout table is used to present Registration Errors.'})
    if errtable is not None:
        error = errtable.findAll('td',{'class': "dddefault"})[0].a.text
        if error.startswith("Open"):
            print("* Must enter the waitlist section.")
            return MinervaError.reg_wait
        else:    
            print("\033[1m* Failed to register: \033[0m " + str(error))
            return MinervaError.reg_fail
    

    print("\033[1m* Registration probably succeeded.\033[0m")
    return MinervaError.reg_ok

def quick_add_issue(message):
    print("\033[1m* Failed to register: \033[0m " +  message + " [Message generated by Minervaclient.]")
    return MinervaError.reg_fail


def quick_add_wait(text):
    html = BeautifulSoup(text, html_parser)
    forms = html.body.find_all('form')
    try:
        reg = forms[1]
    except IndexError:
        sys.exit(quick_add_issue("Registration not open yet."))

    inputs = reg.find_all(['input','select'])
    request = []
    actual_wait = False

    for input in inputs:
        
        if not input.has_attr('name'):
            if input.has_attr('id'):
                print("A problem occurred:")
            else:
                continue

        
        if input.has_attr('value'): #This should always fail for a select.
            val = input['value']
        else:
            val = ''


        if input.has_attr('id') and input['id'].startswith('waitaction'):
            val = 'LW'
            actual_wait = True

        request.append((input['name'], val))
    
        if actual_wait:
            return urllib.parse.urlencode(request)
        else:
            return False
