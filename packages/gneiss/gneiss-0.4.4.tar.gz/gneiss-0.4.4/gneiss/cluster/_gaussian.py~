import pymc3 as pm, theano.tensor as tt



# Below we have code for calculating PLS balances
def _solve(w1, w2, m1, m2, std1, std2):
    # from stackoverflow
    # https://stackoverflow.com/a/22579904/1167475
    a = 1/(2*std1**2) - 1/(2*std2**2)
    b = m2/(std2**2) - m1/(std1**2)
    c = m1**2 /(2*std1**2) - m2**2 / (2*std2**2) - np.log((w1/w2) * np.sqrt(std2/std1))
    return np.roots([a,b,c])


class Gaussian3Mixture():

    def __init__(data)

    ndata = len(data)
    k = 3
    model = pm.Model()
    with model:
        # cluster sizes
        p = pm.Dirichlet('p', a=np.array([1., 1., 1.]), shape=k)
        # ensure all clusters have some points
        p_min_potential = pm.Potential('p_min_potential', tt.switch(tt.min(p) < .1, -np.inf, 0))


        # cluster centers
        means = pm.Normal('means', mu=[-1, 0, 1], sd=5, shape=k)
        # break symmetry
        order_means_potential = pm.Potential('order_means_potential',
                                             tt.switch(means[1]-means[0] < 0, -np.inf, 0)
                                             + tt.switch(means[2]-means[1] < 0, -np.inf, 0)
                                             + tt.switch(means[0] > 0, -np.inf, 0)
                                             + tt.switch(means[2] < 0, -np.inf, 0)
                                            )

        # measurement error
        sd = pm.Uniform('sd', lower=0, upper=5)

        # latent cluster of each observation
        category = pm.Categorical('category',
                                  p=p,
                                  shape=ndata)

        # likelihood for each observed value
        points = pm.Normal('obs',
                           mu=means[category],
                           sd=sd,
                           observed=data)
