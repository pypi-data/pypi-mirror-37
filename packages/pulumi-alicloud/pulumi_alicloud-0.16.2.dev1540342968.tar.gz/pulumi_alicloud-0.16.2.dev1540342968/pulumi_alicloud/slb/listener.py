# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime
from .. import utilities

class Listener(pulumi.CustomResource):
    """
    Provides an Application Load Balancer Listener resource.
    
    For information about slb and how to use it, see [What is Server Load Balancer](https://www.alibabacloud.com/help/doc-detail/27539.htm).
    
    For information about listener and how to use it, see [Configure a Listener](https://www.alibabacloud.com/help/doc-detail/27594.htm).
    
    """
    def __init__(__self__, __name__, __opts__=None, acl_id=None, acl_status=None, acl_type=None, backend_port=None, bandwidth=None, cookie=None, cookie_timeout=None, frontend_port=None, gzip=None, health_check=None, health_check_connect_port=None, health_check_domain=None, health_check_http_code=None, health_check_interval=None, health_check_timeout=None, health_check_type=None, health_check_uri=None, healthy_threshold=None, instance_port=None, lb_port=None, lb_protocol=None, load_balancer_id=None, persistence_timeout=None, protocol=None, scheduler=None, server_group_id=None, ssl_certificate_id=None, sticky_session=None, sticky_session_type=None, unhealthy_threshold=None, x_forwarded_for=None):
        """Create a Listener resource with the given unique name, props, and options."""
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, basestring):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if acl_id and not isinstance(acl_id, basestring):
            raise TypeError('Expected property acl_id to be a basestring')
        __self__.acl_id = acl_id
        """
        the id of access control list to be apply on the listener, is the id of resource alicloud_slb_acl. If `acl_status` is "on", it is mandatory. Otherwise, it will be ignored.
        """
        __props__['aclId'] = acl_id

        if acl_status and not isinstance(acl_status, basestring):
            raise TypeError('Expected property acl_status to be a basestring')
        __self__.acl_status = acl_status
        """
        Whether to enable "acl(access control list)", the acl is specified by `acl_id`. Valid values are `on` and `off`. Default to `off`.
        """
        __props__['aclStatus'] = acl_status

        if acl_type and not isinstance(acl_type, basestring):
            raise TypeError('Expected property acl_type to be a basestring')
        __self__.acl_type = acl_type
        """
        Mode for handling the acl specified by acl_id. If `acl_status` is "on", it is mandatory. Otherwise, it will be ignored. Valid values are `white` and `black`. `white` means the Listener can only be accessed by client ip belongs to the acl; `black` means the Listener can not be accessed by client ip belongs to the acl;
        """
        __props__['aclType'] = acl_type

        if not backend_port:
            raise TypeError('Missing required property backend_port')
        elif not isinstance(backend_port, int):
            raise TypeError('Expected property backend_port to be a int')
        __self__.backend_port = backend_port
        """
        Port used by the Server Load Balancer instance backend. Valid value range: [1-65535].
        """
        __props__['backendPort'] = backend_port

        if not bandwidth:
            raise TypeError('Missing required property bandwidth')
        elif not isinstance(bandwidth, int):
            raise TypeError('Expected property bandwidth to be a int')
        __self__.bandwidth = bandwidth
        """
        Bandwidth peak of Listener. For the public network instance charged per traffic consumed, the Bandwidth on Listener can be set to -1, indicating the bandwidth peak is unlimited. Valid values are [-1, 1-1000] in Mbps.
        """
        __props__['bandwidth'] = bandwidth

        if cookie and not isinstance(cookie, basestring):
            raise TypeError('Expected property cookie to be a basestring')
        __self__.cookie = cookie
        """
        The cookie configured on the server. It is mandatory when `sticky_session` is "on" and `sticky_session_type` is "server". Otherwise, it will be ignored. Valid value：String in line with RFC 2965, with length being 1- 200. It only contains characters such as ASCII codes, English letters and digits instead of the comma, semicolon or spacing, and it cannot start with $.
        """
        __props__['cookie'] = cookie

        if cookie_timeout and not isinstance(cookie_timeout, int):
            raise TypeError('Expected property cookie_timeout to be a int')
        __self__.cookie_timeout = cookie_timeout
        """
        Cookie timeout. It is mandatory when `sticky_session` is "on" and `sticky_session_type` is "insert". Otherwise, it will be ignored. Valid value range: [1-86400] in seconds.
        """
        __props__['cookieTimeout'] = cookie_timeout

        if not frontend_port:
            raise TypeError('Missing required property frontend_port')
        elif not isinstance(frontend_port, int):
            raise TypeError('Expected property frontend_port to be a int')
        __self__.frontend_port = frontend_port
        """
        Port used by the Server Load Balancer instance frontend. Valid value range: [1-65535].
        """
        __props__['frontendPort'] = frontend_port

        if gzip and not isinstance(gzip, bool):
            raise TypeError('Expected property gzip to be a bool')
        __self__.gzip = gzip
        """
        Whether to enable "Gzip Compression". If enabled, files of specific file types will be compressed, otherwise, no files will be compressed. Default to true. Available in v1.13.0+.
        """
        __props__['gzip'] = gzip

        if health_check and not isinstance(health_check, basestring):
            raise TypeError('Expected property health_check to be a basestring')
        __self__.health_check = health_check
        """
        Whether to enable health check. Valid values are`on` and `off`. TCP and UDP listener's HealthCheck is always on, so it will be ignore when launching TCP or UDP listener.
        """
        __props__['healthCheck'] = health_check

        if health_check_connect_port and not isinstance(health_check_connect_port, int):
            raise TypeError('Expected property health_check_connect_port to be a int')
        __self__.health_check_connect_port = health_check_connect_port
        """
        Port used for health check. Valid value range: [1-65535]. Default to "None" means the backend server port is used.
        """
        __props__['healthCheckConnectPort'] = health_check_connect_port

        if health_check_domain and not isinstance(health_check_domain, basestring):
            raise TypeError('Expected property health_check_domain to be a basestring')
        __self__.health_check_domain = health_check_domain
        """
        Domain name used for health check. When it used to launch TCP listener, `health_check_type` must be "http". Its length is limited to 1-80 and only characters such as letters, digits, ‘-‘ and ‘.’ are allowed. When it is not set or empty,  Server Load Balancer uses the private network IP address of each backend server as Domain used for health check.
        """
        __props__['healthCheckDomain'] = health_check_domain

        if health_check_http_code and not isinstance(health_check_http_code, basestring):
            raise TypeError('Expected property health_check_http_code to be a basestring')
        __self__.health_check_http_code = health_check_http_code
        """
        Regular health check HTTP status code. Multiple codes are segmented by “,”. It is required when `health_check` is on. Default to `http_2xx`.  Valid values are: `http_2xx`,  `http_3xx`, `http_4xx` and `http_5xx`.
        """
        __props__['healthCheckHttpCode'] = health_check_http_code

        if health_check_interval and not isinstance(health_check_interval, int):
            raise TypeError('Expected property health_check_interval to be a int')
        __self__.health_check_interval = health_check_interval
        """
        Time interval of health checks. It is required when `health_check` is on. Valid value range: [1-50] in seconds. Default to 2.
        """
        __props__['healthCheckInterval'] = health_check_interval

        if health_check_timeout and not isinstance(health_check_timeout, int):
            raise TypeError('Expected property health_check_timeout to be a int')
        __self__.health_check_timeout = health_check_timeout
        """
        Maximum timeout of each health check response. It is required when `health_check` is on. Valid value range: [1-300] in seconds. Default to 5. Note: If `health_check_timeout` < `health_check_interval`, its will be replaced by `health_check_interval`.
        """
        __props__['healthCheckTimeout'] = health_check_timeout

        if health_check_type and not isinstance(health_check_type, basestring):
            raise TypeError('Expected property health_check_type to be a basestring')
        __self__.health_check_type = health_check_type
        """
        Type of health check. Valid values are: `tcp` and `http`. Default to `tcp` . TCP supports TCP and HTTP health check mode, you can select the particular mode depending on your application.
        """
        __props__['healthCheckType'] = health_check_type

        if health_check_uri and not isinstance(health_check_uri, basestring):
            raise TypeError('Expected property health_check_uri to be a basestring')
        __self__.health_check_uri = health_check_uri
        """
        URI used for health check. When it used to launch TCP listener, `health_check_type` must be "http". Its length is limited to 1-80 and it must start with /. Only characters such as letters, digits, ‘-’, ‘/’, ‘.’, ‘%’, ‘?’, #’ and ‘&’ are allowed.
        """
        __props__['healthCheckUri'] = health_check_uri

        if healthy_threshold and not isinstance(healthy_threshold, int):
            raise TypeError('Expected property healthy_threshold to be a int')
        __self__.healthy_threshold = healthy_threshold
        """
        Threshold determining the result of the health check is success. It is required when `health_check` is on. Valid value range: [1-10] in seconds. Default to 3.
        """
        __props__['healthyThreshold'] = healthy_threshold

        if instance_port and not isinstance(instance_port, int):
            raise TypeError('Expected property instance_port to be a int')
        __self__.instance_port = instance_port
        __props__['instancePort'] = instance_port

        if lb_port and not isinstance(lb_port, int):
            raise TypeError('Expected property lb_port to be a int')
        __self__.lb_port = lb_port
        __props__['lbPort'] = lb_port

        if lb_protocol and not isinstance(lb_protocol, basestring):
            raise TypeError('Expected property lb_protocol to be a basestring')
        __self__.lb_protocol = lb_protocol
        __props__['lbProtocol'] = lb_protocol

        if not load_balancer_id:
            raise TypeError('Missing required property load_balancer_id')
        elif not isinstance(load_balancer_id, basestring):
            raise TypeError('Expected property load_balancer_id to be a basestring')
        __self__.load_balancer_id = load_balancer_id
        """
        The Load Balancer ID which is used to launch a new listener.
        """
        __props__['loadBalancerId'] = load_balancer_id

        if persistence_timeout and not isinstance(persistence_timeout, int):
            raise TypeError('Expected property persistence_timeout to be a int')
        __self__.persistence_timeout = persistence_timeout
        """
        Timeout of connection persistence. Valid value range: [0-3600] in seconds. Default to 0 and means closing it.
        """
        __props__['persistenceTimeout'] = persistence_timeout

        if not protocol:
            raise TypeError('Missing required property protocol')
        elif not isinstance(protocol, basestring):
            raise TypeError('Expected property protocol to be a basestring')
        __self__.protocol = protocol
        """
        The protocol to listen on. Valid values are [`http`, `https`, `tcp`, `udp`].
        """
        __props__['protocol'] = protocol

        if scheduler and not isinstance(scheduler, basestring):
            raise TypeError('Expected property scheduler to be a basestring')
        __self__.scheduler = scheduler
        """
        Scheduling algorithm, Valid values are `wrr` and `wlc`.  Default to "wrr".
        """
        __props__['scheduler'] = scheduler

        if server_group_id and not isinstance(server_group_id, basestring):
            raise TypeError('Expected property server_group_id to be a basestring')
        __self__.server_group_id = server_group_id
        __props__['serverGroupId'] = server_group_id

        if ssl_certificate_id and not isinstance(ssl_certificate_id, basestring):
            raise TypeError('Expected property ssl_certificate_id to be a basestring')
        __self__.ssl_certificate_id = ssl_certificate_id
        """
        Security certificate ID. It is required when `protocol` is `https`.
        """
        __props__['sslCertificateId'] = ssl_certificate_id

        if sticky_session and not isinstance(sticky_session, basestring):
            raise TypeError('Expected property sticky_session to be a basestring')
        __self__.sticky_session = sticky_session
        """
        Whether to enable session persistence, Valid values are `on` and `off`. Default to `off`.
        """
        __props__['stickySession'] = sticky_session

        if sticky_session_type and not isinstance(sticky_session_type, basestring):
            raise TypeError('Expected property sticky_session_type to be a basestring')
        __self__.sticky_session_type = sticky_session_type
        """
        Mode for handling the cookie. If `sticky_session` is "on", it is mandatory. Otherwise, it will be ignored. Valid values are `insert` and `server`. `insert` means it is inserted from Server Load Balancer; `server` means the Server Load Balancer learns from the backend server.
        """
        __props__['stickySessionType'] = sticky_session_type

        if unhealthy_threshold and not isinstance(unhealthy_threshold, int):
            raise TypeError('Expected property unhealthy_threshold to be a int')
        __self__.unhealthy_threshold = unhealthy_threshold
        """
        Threshold determining the result of the health check is fail. It is required when `health_check` is on. Valid value range: [1-10] in seconds. Default to 3.
        """
        __props__['unhealthyThreshold'] = unhealthy_threshold

        if x_forwarded_for and not isinstance(x_forwarded_for, dict):
            raise TypeError('Expected property x_forwarded_for to be a dict')
        __self__.x_forwarded_for = x_forwarded_for
        """
        Whether to set additional HTTP Header field "X-Forwarded-For" (documented below). Available in v1.13.0+.
        """
        __props__['xForwardedFor'] = x_forwarded_for

        super(Listener, __self__).__init__(
            'alicloud:slb/listener:Listener',
            __name__,
            __props__,
            __opts__)

    def set_outputs(self, outs):
        if 'aclId' in outs:
            self.acl_id = outs['aclId']
        if 'aclStatus' in outs:
            self.acl_status = outs['aclStatus']
        if 'aclType' in outs:
            self.acl_type = outs['aclType']
        if 'backendPort' in outs:
            self.backend_port = outs['backendPort']
        if 'bandwidth' in outs:
            self.bandwidth = outs['bandwidth']
        if 'cookie' in outs:
            self.cookie = outs['cookie']
        if 'cookieTimeout' in outs:
            self.cookie_timeout = outs['cookieTimeout']
        if 'frontendPort' in outs:
            self.frontend_port = outs['frontendPort']
        if 'gzip' in outs:
            self.gzip = outs['gzip']
        if 'healthCheck' in outs:
            self.health_check = outs['healthCheck']
        if 'healthCheckConnectPort' in outs:
            self.health_check_connect_port = outs['healthCheckConnectPort']
        if 'healthCheckDomain' in outs:
            self.health_check_domain = outs['healthCheckDomain']
        if 'healthCheckHttpCode' in outs:
            self.health_check_http_code = outs['healthCheckHttpCode']
        if 'healthCheckInterval' in outs:
            self.health_check_interval = outs['healthCheckInterval']
        if 'healthCheckTimeout' in outs:
            self.health_check_timeout = outs['healthCheckTimeout']
        if 'healthCheckType' in outs:
            self.health_check_type = outs['healthCheckType']
        if 'healthCheckUri' in outs:
            self.health_check_uri = outs['healthCheckUri']
        if 'healthyThreshold' in outs:
            self.healthy_threshold = outs['healthyThreshold']
        if 'instancePort' in outs:
            self.instance_port = outs['instancePort']
        if 'lbPort' in outs:
            self.lb_port = outs['lbPort']
        if 'lbProtocol' in outs:
            self.lb_protocol = outs['lbProtocol']
        if 'loadBalancerId' in outs:
            self.load_balancer_id = outs['loadBalancerId']
        if 'persistenceTimeout' in outs:
            self.persistence_timeout = outs['persistenceTimeout']
        if 'protocol' in outs:
            self.protocol = outs['protocol']
        if 'scheduler' in outs:
            self.scheduler = outs['scheduler']
        if 'serverGroupId' in outs:
            self.server_group_id = outs['serverGroupId']
        if 'sslCertificateId' in outs:
            self.ssl_certificate_id = outs['sslCertificateId']
        if 'stickySession' in outs:
            self.sticky_session = outs['stickySession']
        if 'stickySessionType' in outs:
            self.sticky_session_type = outs['stickySessionType']
        if 'unhealthyThreshold' in outs:
            self.unhealthy_threshold = outs['unhealthyThreshold']
        if 'xForwardedFor' in outs:
            self.x_forwarded_for = outs['xForwardedFor']
