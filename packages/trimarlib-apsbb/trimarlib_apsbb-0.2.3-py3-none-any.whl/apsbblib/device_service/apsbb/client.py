#
# Generated by erpcgen 1.6.0 on Fri Oct 19 12:54:49 2018.
#
# AUTOGENERATED - DO NOT EDIT
#

import erpc
from . import common, interface

# Client for System
class SystemClient(interface.ISystem):
    def __init__(self, manager):
        super(SystemClient, self).__init__()
        self._clientManager = manager

    def sys_firmware_version(self, major, minor, maintenance, crc):
        assert type(major) is erpc.Reference, "out parameter must be a Reference object"
        assert type(minor) is erpc.Reference, "out parameter must be a Reference object"
        assert type(maintenance) is erpc.Reference, "out parameter must be a Reference object"
        assert type(crc) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.SYS_FIRMWARE_VERSION_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        major.value = codec.read_uint32()
        minor.value = codec.read_uint32()
        maintenance.value = codec.read_uint32()
        crc.value = codec.read_uint32()
        _result = codec.read_string()
        return _result

    def sys_reset(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request(isOneway=True)
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kOnewayMessage,
                service=self.SERVICE_ID,
                request=self.SYS_RESET_ID,
                sequence=request.sequence))

        # Send request.
        self._clientManager.perform_request(request)

    def sys_bootloader(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request(isOneway=True)
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kOnewayMessage,
                service=self.SERVICE_ID,
                request=self.SYS_BOOTLOADER_ID,
                sequence=request.sequence))

        # Send request.
        self._clientManager.perform_request(request)

    def sys_set_rtc(self, tv):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.SYS_SET_RTC_ID,
                sequence=request.sequence))
        if tv is None:
            raise ValueError("tv is None")
        tv._write(codec)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def sys_get_rtc(self, tv):
        assert type(tv) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.SYS_GET_RTC_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        tv.value = common.Timeval()._read(codec)

    def sys_get_interrupt(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.SYS_GET_INTERRUPT_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint16()
        return _result

    def sys_clear_interrupt(self, mask):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.SYS_CLEAR_INTERRUPT_ID,
                sequence=request.sequence))
        if mask is None:
            raise ValueError("mask is None")
        codec.write_uint16(mask)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def sys_get_erpc_error_count(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.SYS_GET_ERPC_ERROR_COUNT_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint32()
        return _result

    def sys_get_erpc_last_error(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.SYS_GET_ERPC_LAST_ERROR_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint32()
        return _result


# Client for Button
class ButtonClient(interface.IButton):
    def __init__(self, manager):
        super(ButtonClient, self).__init__()
        self._clientManager = manager

    def btn_is_pressed(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BTN_IS_PRESSED_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_bool()
        return _result

    def btn_press_time(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BTN_PRESS_TIME_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint32()
        return _result

    def btn_set_invert(self, enable):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BTN_SET_INVERT_ID,
                sequence=request.sequence))
        if enable is None:
            raise ValueError("enable is None")
        codec.write_bool(enable)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def btn_get_invert(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BTN_GET_INVERT_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_bool()
        return _result

    def btn_set_enabled(self, enable):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BTN_SET_ENABLED_ID,
                sequence=request.sequence))
        if enable is None:
            raise ValueError("enable is None")
        codec.write_bool(enable)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def btn_get_enabled(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BTN_GET_ENABLED_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_bool()
        return _result

    def btn_set_config(self, enable, invert):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BTN_SET_CONFIG_ID,
                sequence=request.sequence))
        if enable is None:
            raise ValueError("enable is None")
        codec.write_bool(enable)
        if invert is None:
            raise ValueError("invert is None")
        codec.write_bool(invert)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def btn_get_config(self, enable, invert):
        assert type(enable) is erpc.Reference, "out parameter must be a Reference object"
        assert type(invert) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BTN_GET_CONFIG_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        enable.value = codec.read_bool()
        invert.value = codec.read_bool()


# Client for RGB
class RGBClient(interface.IRGB):
    def __init__(self, manager):
        super(RGBClient, self).__init__()
        self._clientManager = manager

    def rgb_set_colour(self, colour):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.RGB_SET_COLOUR_ID,
                sequence=request.sequence))
        if colour is None:
            raise ValueError("colour is None")
        colour._write(codec)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def rgb_get_colour(self, colour):
        assert type(colour) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.RGB_GET_COLOUR_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        colour.value = common.Colour()._read(codec)

    def rgb_set_timings(self, timings):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.RGB_SET_TIMINGS_ID,
                sequence=request.sequence))
        if timings is None:
            raise ValueError("timings is None")
        timings._write(codec)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def rgb_get_timings(self, timings):
        assert type(timings) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.RGB_GET_TIMINGS_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        timings.value = common.Timings()._read(codec)

    def rgb_set_mode(self, mode):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.RGB_SET_MODE_ID,
                sequence=request.sequence))
        if mode is None:
            raise ValueError("mode is None")
        codec.write_uint32(mode)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def rgb_get_mode(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.RGB_GET_MODE_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint32()
        return _result

    def rgb_set_coefficients(self, coeffs):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.RGB_SET_COEFFICIENTS_ID,
                sequence=request.sequence))
        if coeffs is None:
            raise ValueError("coeffs is None")
        coeffs._write(codec)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def rgb_get_coefficients(self, coeffs):
        assert type(coeffs) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.RGB_GET_COEFFICIENTS_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        coeffs.value = common.Coefficients()._read(codec)

    def rgb_set_config(self, mode, timings, colour, coeffs):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.RGB_SET_CONFIG_ID,
                sequence=request.sequence))
        if mode is None:
            raise ValueError("mode is None")
        codec.write_uint32(mode)
        if timings is None:
            raise ValueError("timings is None")
        timings._write(codec)
        if colour is None:
            raise ValueError("colour is None")
        colour._write(codec)
        if coeffs is None:
            raise ValueError("coeffs is None")
        coeffs._write(codec)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def rgb_get_config(self, mode, timings, colour, coeffs):
        assert type(mode) is erpc.Reference, "out parameter must be a Reference object"
        assert type(timings) is erpc.Reference, "out parameter must be a Reference object"
        assert type(colour) is erpc.Reference, "out parameter must be a Reference object"
        assert type(coeffs) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.RGB_GET_CONFIG_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        mode.value = codec.read_uint32()
        timings.value = common.Timings()._read(codec)
        colour.value = common.Colour()._read(codec)
        coeffs.value = common.Coefficients()._read(codec)


# Client for Path
class PathClient(interface.IPath):
    def __init__(self, manager):
        super(PathClient, self).__init__()
        self._clientManager = manager

    def path_get_status(self, status):
        assert type(status) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_GET_STATUS_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        status.value = common.PathStatus()._read(codec)

    def path_open(self, force, autoClose):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_OPEN_ID,
                sequence=request.sequence))
        if force is None:
            raise ValueError("force is None")
        codec.write_bool(force)
        if autoClose is None:
            raise ValueError("autoClose is None")
        codec.write_bool(autoClose)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def path_close(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_CLOSE_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def path_set_barrier_timeout(self, timeout):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_SET_BARRIER_TIMEOUT_ID,
                sequence=request.sequence))
        if timeout is None:
            raise ValueError("timeout is None")
        codec.write_uint16(timeout)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def path_get_barrier_timeout(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_GET_BARRIER_TIMEOUT_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint16()
        return _result

    def path_set_loopA_timeout(self, timeout):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_SET_LOOPA_TIMEOUT_ID,
                sequence=request.sequence))
        if timeout is None:
            raise ValueError("timeout is None")
        codec.write_uint16(timeout)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def path_get_loopA_timeout(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_GET_LOOPA_TIMEOUT_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint16()
        return _result

    def path_set_loopB_timeout(self, timeout):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_SET_LOOPB_TIMEOUT_ID,
                sequence=request.sequence))
        if timeout is None:
            raise ValueError("timeout is None")
        codec.write_uint16(timeout)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def path_get_loopB_timeout(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_GET_LOOPB_TIMEOUT_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint16()
        return _result

    def path_set_loops_hold(self, time):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_SET_LOOPS_HOLD_ID,
                sequence=request.sequence))
        if time is None:
            raise ValueError("time is None")
        codec.write_uint16(time)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def path_get_loops_hold(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_GET_LOOPS_HOLD_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint16()
        return _result

    def path_get_result(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_GET_RESULT_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint32()
        return _result

    def path_clear_result(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_CLEAR_RESULT_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def path_set_config(self, barrier_timeout, loopA_timeout, loopB_timeout, loops_hold):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_SET_CONFIG_ID,
                sequence=request.sequence))
        if barrier_timeout is None:
            raise ValueError("barrier_timeout is None")
        codec.write_uint16(barrier_timeout)
        if loopA_timeout is None:
            raise ValueError("loopA_timeout is None")
        codec.write_uint16(loopA_timeout)
        if loopB_timeout is None:
            raise ValueError("loopB_timeout is None")
        codec.write_uint16(loopB_timeout)
        if loops_hold is None:
            raise ValueError("loops_hold is None")
        codec.write_uint16(loops_hold)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def path_get_config(self, barrier_timeout, loopA_timeout, loopB_timeout, loops_hold):
        assert type(barrier_timeout) is erpc.Reference, "out parameter must be a Reference object"
        assert type(loopA_timeout) is erpc.Reference, "out parameter must be a Reference object"
        assert type(loopB_timeout) is erpc.Reference, "out parameter must be a Reference object"
        assert type(loops_hold) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.PATH_GET_CONFIG_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        barrier_timeout.value = codec.read_uint16()
        loopA_timeout.value = codec.read_uint16()
        loopB_timeout.value = codec.read_uint16()
        loops_hold.value = codec.read_uint16()


# Client for Buzzer
class BuzzerClient(interface.IBuzzer):
    def __init__(self, manager):
        super(BuzzerClient, self).__init__()
        self._clientManager = manager

    def buzzer_set_frequency(self, frequency):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BUZZER_SET_FREQUENCY_ID,
                sequence=request.sequence))
        if frequency is None:
            raise ValueError("frequency is None")
        codec.write_uint16(frequency)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def buzzer_get_frequency(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BUZZER_GET_FREQUENCY_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint16()
        return _result

    def buzzer_enable(self, onTime, offTime, repeat):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BUZZER_ENABLE_ID,
                sequence=request.sequence))
        if onTime is None:
            raise ValueError("onTime is None")
        codec.write_uint16(onTime)
        if offTime is None:
            raise ValueError("offTime is None")
        codec.write_uint16(offTime)
        if repeat is None:
            raise ValueError("repeat is None")
        codec.write_int16(repeat)

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def buzzer_enable_ACK(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BUZZER_ENABLE_ACK_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)

    def buzzer_enable_NAK(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.BUZZER_ENABLE_NAK_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)


# Client for MDB
class MDBClient(interface.IMDB):
    def __init__(self, manager):
        super(MDBClient, self).__init__()
        self._clientManager = manager

    def mdb_execute_command(self, addr_cmd, txbuf, rxbuf):
        assert type(rxbuf) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_EXECUTE_COMMAND_ID,
                sequence=request.sequence))
        if addr_cmd is None:
            raise ValueError("addr_cmd is None")
        codec.write_uint8(addr_cmd)
        if txbuf is None:
            raise ValueError("txbuf is None")
        codec.start_write_list(self.length)
        for _i0 in txbuf:
            codec.write_uint8(_i0)


        # Send request and process reply.
        self._clientManager.perform_request(request)
        _n0 = codec.start_read_list()
        rxbuf.value = []
        for _i0 in range(_n0):
            _v0 = codec.read_uint8()
            rxbuf.value.append(_v0)

        _result = codec.read_int8()
        return _result

    def mdb_coin_changer_get_status(self):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_GET_STATUS_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_uint32()
        return _result

    def mdb_coin_changer_get_setup_data(self, data):
        assert type(data) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_GET_SETUP_DATA_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        data.value = common.CoinChangerSetupData()._read(codec)

    def mdb_coin_changer_get_expansion_data(self, data):
        assert type(data) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_GET_EXPANSION_DATA_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        data.value = common.CoinChangerExpansionData()._read(codec)

    def mdb_coin_changer_get_diagnostic_status(self, status):
        assert type(status) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_GET_DIAGNOSTIC_STATUS_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        status.value = []
        for _i0 in range(2):
            _v0 = codec.read_uint8()
            status.value.append(_v0)


    def mdb_coin_changer_tube_status(self, full, status):
        assert type(full) is erpc.Reference, "out parameter must be a Reference object"
        assert type(status) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_TUBE_STATUS_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        full.value = codec.read_uint16()
        status.value = []
        for _i0 in range(16):
            _v0 = codec.read_uint8()
            status.value.append(_v0)

        _result = codec.read_int8()
        return _result

    def mdb_coin_changer_coin_type(self, coin_enable, dispense_enable):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_COIN_TYPE_ID,
                sequence=request.sequence))
        if coin_enable is None:
            raise ValueError("coin_enable is None")
        codec.write_uint16(coin_enable)
        if dispense_enable is None:
            raise ValueError("dispense_enable is None")
        codec.write_uint16(dispense_enable)

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_int8()
        return _result

    def mdb_coin_changer_dispense(self, typ, cnt):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_DISPENSE_ID,
                sequence=request.sequence))
        if typ is None:
            raise ValueError("typ is None")
        codec.write_uint8(typ)
        if cnt is None:
            raise ValueError("cnt is None")
        codec.write_uint8(cnt)

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_int8()
        return _result

    def mdb_coin_changer_expansion_feature_enable(self, feature_mask):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_EXPANSION_FEATURE_ENABLE_ID,
                sequence=request.sequence))
        if feature_mask is None:
            raise ValueError("feature_mask is None")
        codec.write_uint32(feature_mask)

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_int8()
        return _result

    def mdb_coin_changer_expansion_payout(self, value):
        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_EXPANSION_PAYOUT_ID,
                sequence=request.sequence))
        if value is None:
            raise ValueError("value is None")
        codec.write_uint8(value)

        # Send request and process reply.
        self._clientManager.perform_request(request)
        _result = codec.read_int8()
        return _result

    def mdb_coin_changer_expansion_payout_status(self, status):
        assert type(status) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_EXPANSION_PAYOUT_STATUS_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        status.value = []
        for _i0 in range(16):
            _v0 = codec.read_uint8()
            status.value.append(_v0)

        _result = codec.read_int8()
        return _result

    def mdb_coin_changer_expansion_payout_poll(self, value):
        assert type(value) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_EXPANSION_PAYOUT_POLL_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        value.value = codec.read_uint8()
        _result = codec.read_int8()
        return _result

    def mdb_coin_changer_expansion_send_controlled_manual_fill_report(self, buf):
        assert type(buf) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_EXPANSION_SEND_CONTROLLED_MANUAL_FILL_REPORT_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        buf.value = []
        for _i0 in range(16):
            _v0 = codec.read_uint8()
            buf.value.append(_v0)

        _result = codec.read_int8()
        return _result

    def mdb_coin_changer_expansion_send_controlled_manual_payout_report(self, buf):
        assert type(buf) is erpc.Reference, "out parameter must be a Reference object"

        # Build remote function invocation message.
        request = self._clientManager.create_request()
        codec = request.codec
        codec.start_write_message(erpc.codec.MessageInfo(
                type=erpc.codec.MessageType.kInvocationMessage,
                service=self.SERVICE_ID,
                request=self.MDB_COIN_CHANGER_EXPANSION_SEND_CONTROLLED_MANUAL_PAYOUT_REPORT_ID,
                sequence=request.sequence))

        # Send request and process reply.
        self._clientManager.perform_request(request)
        buf.value = []
        for _i0 in range(16):
            _v0 = codec.read_uint8()
            buf.value.append(_v0)

        _result = codec.read_int8()
        return _result



