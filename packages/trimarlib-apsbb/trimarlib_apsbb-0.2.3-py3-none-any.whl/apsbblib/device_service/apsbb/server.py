#
# Generated by erpcgen 1.6.0 on Fri Oct 19 12:54:49 2018.
#
# AUTOGENERATED - DO NOT EDIT
#

import erpc
from . import common, interface

# Client for System
class SystemService(erpc.server.Service):
    def __init__(self, handler):
        super(SystemService, self).__init__(interface.ISystem.SERVICE_ID)
        self._handler = handler
        self._methods = {
                interface.ISystem.SYS_FIRMWARE_VERSION_ID: self._handle_sys_firmware_version,
                interface.ISystem.SYS_RESET_ID: self._handle_sys_reset,
                interface.ISystem.SYS_BOOTLOADER_ID: self._handle_sys_bootloader,
                interface.ISystem.SYS_SET_RTC_ID: self._handle_sys_set_rtc,
                interface.ISystem.SYS_GET_RTC_ID: self._handle_sys_get_rtc,
                interface.ISystem.SYS_GET_INTERRUPT_ID: self._handle_sys_get_interrupt,
                interface.ISystem.SYS_CLEAR_INTERRUPT_ID: self._handle_sys_clear_interrupt,
                interface.ISystem.SYS_GET_ERPC_ERROR_COUNT_ID: self._handle_sys_get_erpc_error_count,
                interface.ISystem.SYS_GET_ERPC_LAST_ERROR_ID: self._handle_sys_get_erpc_last_error,
            }

    def _handle_sys_firmware_version(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        major = erpc.Reference()
        minor = erpc.Reference()
        maintenance = erpc.Reference()
        crc = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.sys_firmware_version(major, minor, maintenance, crc)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.ISystem.SERVICE_ID,
            request=interface.ISystem.SYS_FIRMWARE_VERSION_ID,
            sequence=sequence))
        if major.value is None:
            raise ValueError("major is None")
        codec.write_uint32(major.value)
        if minor.value is None:
            raise ValueError("minor is None")
        codec.write_uint32(minor.value)
        if maintenance.value is None:
            raise ValueError("maintenance is None")
        codec.write_uint32(maintenance.value)
        if crc.value is None:
            raise ValueError("crc is None")
        codec.write_uint32(crc.value)
        codec.write_string(_result)

    def _handle_sys_reset(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.sys_reset()

    def _handle_sys_bootloader(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.sys_bootloader()

    def _handle_sys_set_rtc(self, sequence, codec):
        # Read incoming parameters.
        tv = common.Timeval()._read(codec)

        # Invoke user implementation of remote function.
        self._handler.sys_set_rtc(tv)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.ISystem.SERVICE_ID,
            request=interface.ISystem.SYS_SET_RTC_ID,
            sequence=sequence))

    def _handle_sys_get_rtc(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        tv = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.sys_get_rtc(tv)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.ISystem.SERVICE_ID,
            request=interface.ISystem.SYS_GET_RTC_ID,
            sequence=sequence))
        if tv.value is None:
            raise ValueError("tv is None")
        tv.value._write(codec)

    def _handle_sys_get_interrupt(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.sys_get_interrupt()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.ISystem.SERVICE_ID,
            request=interface.ISystem.SYS_GET_INTERRUPT_ID,
            sequence=sequence))
        codec.write_uint16(_result)

    def _handle_sys_clear_interrupt(self, sequence, codec):
        # Read incoming parameters.
        mask = codec.read_uint16()

        # Invoke user implementation of remote function.
        self._handler.sys_clear_interrupt(mask)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.ISystem.SERVICE_ID,
            request=interface.ISystem.SYS_CLEAR_INTERRUPT_ID,
            sequence=sequence))

    def _handle_sys_get_erpc_error_count(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.sys_get_erpc_error_count()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.ISystem.SERVICE_ID,
            request=interface.ISystem.SYS_GET_ERPC_ERROR_COUNT_ID,
            sequence=sequence))
        codec.write_uint32(_result)

    def _handle_sys_get_erpc_last_error(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.sys_get_erpc_last_error()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.ISystem.SERVICE_ID,
            request=interface.ISystem.SYS_GET_ERPC_LAST_ERROR_ID,
            sequence=sequence))
        codec.write_uint32(_result)


# Client for Button
class ButtonService(erpc.server.Service):
    def __init__(self, handler):
        super(ButtonService, self).__init__(interface.IButton.SERVICE_ID)
        self._handler = handler
        self._methods = {
                interface.IButton.BTN_IS_PRESSED_ID: self._handle_btn_is_pressed,
                interface.IButton.BTN_PRESS_TIME_ID: self._handle_btn_press_time,
                interface.IButton.BTN_SET_INVERT_ID: self._handle_btn_set_invert,
                interface.IButton.BTN_GET_INVERT_ID: self._handle_btn_get_invert,
                interface.IButton.BTN_SET_ENABLED_ID: self._handle_btn_set_enabled,
                interface.IButton.BTN_GET_ENABLED_ID: self._handle_btn_get_enabled,
                interface.IButton.BTN_SET_CONFIG_ID: self._handle_btn_set_config,
                interface.IButton.BTN_GET_CONFIG_ID: self._handle_btn_get_config,
            }

    def _handle_btn_is_pressed(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.btn_is_pressed()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IButton.SERVICE_ID,
            request=interface.IButton.BTN_IS_PRESSED_ID,
            sequence=sequence))
        codec.write_bool(_result)

    def _handle_btn_press_time(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.btn_press_time()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IButton.SERVICE_ID,
            request=interface.IButton.BTN_PRESS_TIME_ID,
            sequence=sequence))
        codec.write_uint32(_result)

    def _handle_btn_set_invert(self, sequence, codec):
        # Read incoming parameters.
        enable = codec.read_bool()

        # Invoke user implementation of remote function.
        self._handler.btn_set_invert(enable)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IButton.SERVICE_ID,
            request=interface.IButton.BTN_SET_INVERT_ID,
            sequence=sequence))

    def _handle_btn_get_invert(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.btn_get_invert()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IButton.SERVICE_ID,
            request=interface.IButton.BTN_GET_INVERT_ID,
            sequence=sequence))
        codec.write_bool(_result)

    def _handle_btn_set_enabled(self, sequence, codec):
        # Read incoming parameters.
        enable = codec.read_bool()

        # Invoke user implementation of remote function.
        self._handler.btn_set_enabled(enable)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IButton.SERVICE_ID,
            request=interface.IButton.BTN_SET_ENABLED_ID,
            sequence=sequence))

    def _handle_btn_get_enabled(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.btn_get_enabled()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IButton.SERVICE_ID,
            request=interface.IButton.BTN_GET_ENABLED_ID,
            sequence=sequence))
        codec.write_bool(_result)

    def _handle_btn_set_config(self, sequence, codec):
        # Read incoming parameters.
        enable = codec.read_bool()
        invert = codec.read_bool()

        # Invoke user implementation of remote function.
        self._handler.btn_set_config(enable, invert)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IButton.SERVICE_ID,
            request=interface.IButton.BTN_SET_CONFIG_ID,
            sequence=sequence))

    def _handle_btn_get_config(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        enable = erpc.Reference()
        invert = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.btn_get_config(enable, invert)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IButton.SERVICE_ID,
            request=interface.IButton.BTN_GET_CONFIG_ID,
            sequence=sequence))
        if enable.value is None:
            raise ValueError("enable is None")
        codec.write_bool(enable.value)
        if invert.value is None:
            raise ValueError("invert is None")
        codec.write_bool(invert.value)


# Client for RGB
class RGBService(erpc.server.Service):
    def __init__(self, handler):
        super(RGBService, self).__init__(interface.IRGB.SERVICE_ID)
        self._handler = handler
        self._methods = {
                interface.IRGB.RGB_SET_COLOUR_ID: self._handle_rgb_set_colour,
                interface.IRGB.RGB_GET_COLOUR_ID: self._handle_rgb_get_colour,
                interface.IRGB.RGB_SET_TIMINGS_ID: self._handle_rgb_set_timings,
                interface.IRGB.RGB_GET_TIMINGS_ID: self._handle_rgb_get_timings,
                interface.IRGB.RGB_SET_MODE_ID: self._handle_rgb_set_mode,
                interface.IRGB.RGB_GET_MODE_ID: self._handle_rgb_get_mode,
                interface.IRGB.RGB_SET_COEFFICIENTS_ID: self._handle_rgb_set_coefficients,
                interface.IRGB.RGB_GET_COEFFICIENTS_ID: self._handle_rgb_get_coefficients,
                interface.IRGB.RGB_SET_CONFIG_ID: self._handle_rgb_set_config,
                interface.IRGB.RGB_GET_CONFIG_ID: self._handle_rgb_get_config,
            }

    def _handle_rgb_set_colour(self, sequence, codec):
        # Read incoming parameters.
        colour = common.Colour()._read(codec)

        # Invoke user implementation of remote function.
        self._handler.rgb_set_colour(colour)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IRGB.SERVICE_ID,
            request=interface.IRGB.RGB_SET_COLOUR_ID,
            sequence=sequence))

    def _handle_rgb_get_colour(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        colour = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.rgb_get_colour(colour)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IRGB.SERVICE_ID,
            request=interface.IRGB.RGB_GET_COLOUR_ID,
            sequence=sequence))
        if colour.value is None:
            raise ValueError("colour is None")
        colour.value._write(codec)

    def _handle_rgb_set_timings(self, sequence, codec):
        # Read incoming parameters.
        timings = common.Timings()._read(codec)

        # Invoke user implementation of remote function.
        self._handler.rgb_set_timings(timings)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IRGB.SERVICE_ID,
            request=interface.IRGB.RGB_SET_TIMINGS_ID,
            sequence=sequence))

    def _handle_rgb_get_timings(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        timings = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.rgb_get_timings(timings)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IRGB.SERVICE_ID,
            request=interface.IRGB.RGB_GET_TIMINGS_ID,
            sequence=sequence))
        if timings.value is None:
            raise ValueError("timings is None")
        timings.value._write(codec)

    def _handle_rgb_set_mode(self, sequence, codec):
        # Read incoming parameters.
        mode = codec.read_uint32()

        # Invoke user implementation of remote function.
        self._handler.rgb_set_mode(mode)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IRGB.SERVICE_ID,
            request=interface.IRGB.RGB_SET_MODE_ID,
            sequence=sequence))

    def _handle_rgb_get_mode(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.rgb_get_mode()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IRGB.SERVICE_ID,
            request=interface.IRGB.RGB_GET_MODE_ID,
            sequence=sequence))
        codec.write_uint32(_result)

    def _handle_rgb_set_coefficients(self, sequence, codec):
        # Read incoming parameters.
        coeffs = common.Coefficients()._read(codec)

        # Invoke user implementation of remote function.
        self._handler.rgb_set_coefficients(coeffs)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IRGB.SERVICE_ID,
            request=interface.IRGB.RGB_SET_COEFFICIENTS_ID,
            sequence=sequence))

    def _handle_rgb_get_coefficients(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        coeffs = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.rgb_get_coefficients(coeffs)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IRGB.SERVICE_ID,
            request=interface.IRGB.RGB_GET_COEFFICIENTS_ID,
            sequence=sequence))
        if coeffs.value is None:
            raise ValueError("coeffs is None")
        coeffs.value._write(codec)

    def _handle_rgb_set_config(self, sequence, codec):
        # Read incoming parameters.
        mode = codec.read_uint32()
        timings = common.Timings()._read(codec)
        colour = common.Colour()._read(codec)
        coeffs = common.Coefficients()._read(codec)

        # Invoke user implementation of remote function.
        self._handler.rgb_set_config(mode, timings, colour, coeffs)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IRGB.SERVICE_ID,
            request=interface.IRGB.RGB_SET_CONFIG_ID,
            sequence=sequence))

    def _handle_rgb_get_config(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        mode = erpc.Reference()
        timings = erpc.Reference()
        colour = erpc.Reference()
        coeffs = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.rgb_get_config(mode, timings, colour, coeffs)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IRGB.SERVICE_ID,
            request=interface.IRGB.RGB_GET_CONFIG_ID,
            sequence=sequence))
        if mode.value is None:
            raise ValueError("mode is None")
        codec.write_uint32(mode.value)
        if timings.value is None:
            raise ValueError("timings is None")
        timings.value._write(codec)
        if colour.value is None:
            raise ValueError("colour is None")
        colour.value._write(codec)
        if coeffs.value is None:
            raise ValueError("coeffs is None")
        coeffs.value._write(codec)


# Client for Path
class PathService(erpc.server.Service):
    def __init__(self, handler):
        super(PathService, self).__init__(interface.IPath.SERVICE_ID)
        self._handler = handler
        self._methods = {
                interface.IPath.PATH_GET_STATUS_ID: self._handle_path_get_status,
                interface.IPath.PATH_OPEN_ID: self._handle_path_open,
                interface.IPath.PATH_CLOSE_ID: self._handle_path_close,
                interface.IPath.PATH_SET_BARRIER_TIMEOUT_ID: self._handle_path_set_barrier_timeout,
                interface.IPath.PATH_GET_BARRIER_TIMEOUT_ID: self._handle_path_get_barrier_timeout,
                interface.IPath.PATH_SET_LOOPA_TIMEOUT_ID: self._handle_path_set_loopA_timeout,
                interface.IPath.PATH_GET_LOOPA_TIMEOUT_ID: self._handle_path_get_loopA_timeout,
                interface.IPath.PATH_SET_LOOPB_TIMEOUT_ID: self._handle_path_set_loopB_timeout,
                interface.IPath.PATH_GET_LOOPB_TIMEOUT_ID: self._handle_path_get_loopB_timeout,
                interface.IPath.PATH_SET_LOOPS_HOLD_ID: self._handle_path_set_loops_hold,
                interface.IPath.PATH_GET_LOOPS_HOLD_ID: self._handle_path_get_loops_hold,
                interface.IPath.PATH_GET_RESULT_ID: self._handle_path_get_result,
                interface.IPath.PATH_CLEAR_RESULT_ID: self._handle_path_clear_result,
                interface.IPath.PATH_SET_CONFIG_ID: self._handle_path_set_config,
                interface.IPath.PATH_GET_CONFIG_ID: self._handle_path_get_config,
            }

    def _handle_path_get_status(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        status = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.path_get_status(status)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_GET_STATUS_ID,
            sequence=sequence))
        if status.value is None:
            raise ValueError("status is None")
        status.value._write(codec)

    def _handle_path_open(self, sequence, codec):
        # Read incoming parameters.
        force = codec.read_bool()
        autoClose = codec.read_bool()

        # Invoke user implementation of remote function.
        self._handler.path_open(force, autoClose)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_OPEN_ID,
            sequence=sequence))

    def _handle_path_close(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.path_close()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_CLOSE_ID,
            sequence=sequence))

    def _handle_path_set_barrier_timeout(self, sequence, codec):
        # Read incoming parameters.
        timeout = codec.read_uint16()

        # Invoke user implementation of remote function.
        self._handler.path_set_barrier_timeout(timeout)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_SET_BARRIER_TIMEOUT_ID,
            sequence=sequence))

    def _handle_path_get_barrier_timeout(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.path_get_barrier_timeout()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_GET_BARRIER_TIMEOUT_ID,
            sequence=sequence))
        codec.write_uint16(_result)

    def _handle_path_set_loopA_timeout(self, sequence, codec):
        # Read incoming parameters.
        timeout = codec.read_uint16()

        # Invoke user implementation of remote function.
        self._handler.path_set_loopA_timeout(timeout)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_SET_LOOPA_TIMEOUT_ID,
            sequence=sequence))

    def _handle_path_get_loopA_timeout(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.path_get_loopA_timeout()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_GET_LOOPA_TIMEOUT_ID,
            sequence=sequence))
        codec.write_uint16(_result)

    def _handle_path_set_loopB_timeout(self, sequence, codec):
        # Read incoming parameters.
        timeout = codec.read_uint16()

        # Invoke user implementation of remote function.
        self._handler.path_set_loopB_timeout(timeout)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_SET_LOOPB_TIMEOUT_ID,
            sequence=sequence))

    def _handle_path_get_loopB_timeout(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.path_get_loopB_timeout()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_GET_LOOPB_TIMEOUT_ID,
            sequence=sequence))
        codec.write_uint16(_result)

    def _handle_path_set_loops_hold(self, sequence, codec):
        # Read incoming parameters.
        time = codec.read_uint16()

        # Invoke user implementation of remote function.
        self._handler.path_set_loops_hold(time)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_SET_LOOPS_HOLD_ID,
            sequence=sequence))

    def _handle_path_get_loops_hold(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.path_get_loops_hold()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_GET_LOOPS_HOLD_ID,
            sequence=sequence))
        codec.write_uint16(_result)

    def _handle_path_get_result(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.path_get_result()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_GET_RESULT_ID,
            sequence=sequence))
        codec.write_uint32(_result)

    def _handle_path_clear_result(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.path_clear_result()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_CLEAR_RESULT_ID,
            sequence=sequence))

    def _handle_path_set_config(self, sequence, codec):
        # Read incoming parameters.
        barrier_timeout = codec.read_uint16()
        loopA_timeout = codec.read_uint16()
        loopB_timeout = codec.read_uint16()
        loops_hold = codec.read_uint16()

        # Invoke user implementation of remote function.
        self._handler.path_set_config(barrier_timeout, loopA_timeout, loopB_timeout, loops_hold)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_SET_CONFIG_ID,
            sequence=sequence))

    def _handle_path_get_config(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        barrier_timeout = erpc.Reference()
        loopA_timeout = erpc.Reference()
        loopB_timeout = erpc.Reference()
        loops_hold = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.path_get_config(barrier_timeout, loopA_timeout, loopB_timeout, loops_hold)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IPath.SERVICE_ID,
            request=interface.IPath.PATH_GET_CONFIG_ID,
            sequence=sequence))
        if barrier_timeout.value is None:
            raise ValueError("barrier_timeout is None")
        codec.write_uint16(barrier_timeout.value)
        if loopA_timeout.value is None:
            raise ValueError("loopA_timeout is None")
        codec.write_uint16(loopA_timeout.value)
        if loopB_timeout.value is None:
            raise ValueError("loopB_timeout is None")
        codec.write_uint16(loopB_timeout.value)
        if loops_hold.value is None:
            raise ValueError("loops_hold is None")
        codec.write_uint16(loops_hold.value)


# Client for Buzzer
class BuzzerService(erpc.server.Service):
    def __init__(self, handler):
        super(BuzzerService, self).__init__(interface.IBuzzer.SERVICE_ID)
        self._handler = handler
        self._methods = {
                interface.IBuzzer.BUZZER_SET_FREQUENCY_ID: self._handle_buzzer_set_frequency,
                interface.IBuzzer.BUZZER_GET_FREQUENCY_ID: self._handle_buzzer_get_frequency,
                interface.IBuzzer.BUZZER_ENABLE_ID: self._handle_buzzer_enable,
                interface.IBuzzer.BUZZER_ENABLE_ACK_ID: self._handle_buzzer_enable_ACK,
                interface.IBuzzer.BUZZER_ENABLE_NAK_ID: self._handle_buzzer_enable_NAK,
            }

    def _handle_buzzer_set_frequency(self, sequence, codec):
        # Read incoming parameters.
        frequency = codec.read_uint16()

        # Invoke user implementation of remote function.
        self._handler.buzzer_set_frequency(frequency)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IBuzzer.SERVICE_ID,
            request=interface.IBuzzer.BUZZER_SET_FREQUENCY_ID,
            sequence=sequence))

    def _handle_buzzer_get_frequency(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.buzzer_get_frequency()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IBuzzer.SERVICE_ID,
            request=interface.IBuzzer.BUZZER_GET_FREQUENCY_ID,
            sequence=sequence))
        codec.write_uint16(_result)

    def _handle_buzzer_enable(self, sequence, codec):
        # Read incoming parameters.
        onTime = codec.read_uint16()
        offTime = codec.read_uint16()
        repeat = codec.read_int16()

        # Invoke user implementation of remote function.
        self._handler.buzzer_enable(onTime, offTime, repeat)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IBuzzer.SERVICE_ID,
            request=interface.IBuzzer.BUZZER_ENABLE_ID,
            sequence=sequence))

    def _handle_buzzer_enable_ACK(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.buzzer_enable_ACK()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IBuzzer.SERVICE_ID,
            request=interface.IBuzzer.BUZZER_ENABLE_ACK_ID,
            sequence=sequence))

    def _handle_buzzer_enable_NAK(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.buzzer_enable_NAK()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IBuzzer.SERVICE_ID,
            request=interface.IBuzzer.BUZZER_ENABLE_NAK_ID,
            sequence=sequence))


# Client for MDB
class MDBService(erpc.server.Service):
    def __init__(self, handler):
        super(MDBService, self).__init__(interface.IMDB.SERVICE_ID)
        self._handler = handler
        self._methods = {
                interface.IMDB.MDB_EXECUTE_COMMAND_ID: self._handle_mdb_execute_command,
                interface.IMDB.MDB_COIN_CHANGER_GET_STATUS_ID: self._handle_mdb_coin_changer_get_status,
                interface.IMDB.MDB_COIN_CHANGER_GET_SETUP_DATA_ID: self._handle_mdb_coin_changer_get_setup_data,
                interface.IMDB.MDB_COIN_CHANGER_GET_EXPANSION_DATA_ID: self._handle_mdb_coin_changer_get_expansion_data,
                interface.IMDB.MDB_COIN_CHANGER_GET_DIAGNOSTIC_STATUS_ID: self._handle_mdb_coin_changer_get_diagnostic_status,
                interface.IMDB.MDB_COIN_CHANGER_TUBE_STATUS_ID: self._handle_mdb_coin_changer_tube_status,
                interface.IMDB.MDB_COIN_CHANGER_COIN_TYPE_ID: self._handle_mdb_coin_changer_coin_type,
                interface.IMDB.MDB_COIN_CHANGER_DISPENSE_ID: self._handle_mdb_coin_changer_dispense,
                interface.IMDB.MDB_COIN_CHANGER_EXPANSION_FEATURE_ENABLE_ID: self._handle_mdb_coin_changer_expansion_feature_enable,
                interface.IMDB.MDB_COIN_CHANGER_EXPANSION_PAYOUT_ID: self._handle_mdb_coin_changer_expansion_payout,
                interface.IMDB.MDB_COIN_CHANGER_EXPANSION_PAYOUT_STATUS_ID: self._handle_mdb_coin_changer_expansion_payout_status,
                interface.IMDB.MDB_COIN_CHANGER_EXPANSION_PAYOUT_POLL_ID: self._handle_mdb_coin_changer_expansion_payout_poll,
                interface.IMDB.MDB_COIN_CHANGER_EXPANSION_SEND_CONTROLLED_MANUAL_FILL_REPORT_ID: self._handle_mdb_coin_changer_expansion_send_controlled_manual_fill_report,
                interface.IMDB.MDB_COIN_CHANGER_EXPANSION_SEND_CONTROLLED_MANUAL_PAYOUT_REPORT_ID: self._handle_mdb_coin_changer_expansion_send_controlled_manual_payout_report,
            }

    def _handle_mdb_execute_command(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        rxbuf = erpc.Reference()

        # Read incoming parameters.
        addr_cmd = codec.read_uint8()
        _n0 = codec.start_read_list()
        txbuf = []
        for _i0 in range(_n0):
            _v0 = codec.read_uint8()
            txbuf.append(_v0)


        # Invoke user implementation of remote function.
        _result = self._handler.mdb_execute_command(addr_cmd, txbuf, rxbuf)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_EXECUTE_COMMAND_ID,
            sequence=sequence))
        if rxbuf.value is None:
            raise ValueError("rxbuf is None")
        codec.start_write_list(self.length)
        for _i0 in rxbuf.value:
            codec.write_uint8(_i0)

        codec.write_int8(_result)

    def _handle_mdb_coin_changer_get_status(self, sequence, codec):
        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.mdb_coin_changer_get_status()

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_GET_STATUS_ID,
            sequence=sequence))
        codec.write_uint32(_result)

    def _handle_mdb_coin_changer_get_setup_data(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        data = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.mdb_coin_changer_get_setup_data(data)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_GET_SETUP_DATA_ID,
            sequence=sequence))
        if data.value is None:
            raise ValueError("data is None")
        data.value._write(codec)

    def _handle_mdb_coin_changer_get_expansion_data(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        data = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.mdb_coin_changer_get_expansion_data(data)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_GET_EXPANSION_DATA_ID,
            sequence=sequence))
        if data.value is None:
            raise ValueError("data is None")
        data.value._write(codec)

    def _handle_mdb_coin_changer_get_diagnostic_status(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        status = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        self._handler.mdb_coin_changer_get_diagnostic_status(status)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_GET_DIAGNOSTIC_STATUS_ID,
            sequence=sequence))
        if status.value is None:
            raise ValueError("status is None")
        for _i0 in status.value:
            codec.write_uint8(_i0)


    def _handle_mdb_coin_changer_tube_status(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        full = erpc.Reference()
        status = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.mdb_coin_changer_tube_status(full, status)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_TUBE_STATUS_ID,
            sequence=sequence))
        if full.value is None:
            raise ValueError("full is None")
        codec.write_uint16(full.value)
        if status.value is None:
            raise ValueError("status is None")
        for _i0 in status.value:
            codec.write_uint8(_i0)

        codec.write_int8(_result)

    def _handle_mdb_coin_changer_coin_type(self, sequence, codec):
        # Read incoming parameters.
        coin_enable = codec.read_uint16()
        dispense_enable = codec.read_uint16()

        # Invoke user implementation of remote function.
        _result = self._handler.mdb_coin_changer_coin_type(coin_enable, dispense_enable)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_COIN_TYPE_ID,
            sequence=sequence))
        codec.write_int8(_result)

    def _handle_mdb_coin_changer_dispense(self, sequence, codec):
        # Read incoming parameters.
        typ = codec.read_uint8()
        cnt = codec.read_uint8()

        # Invoke user implementation of remote function.
        _result = self._handler.mdb_coin_changer_dispense(typ, cnt)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_DISPENSE_ID,
            sequence=sequence))
        codec.write_int8(_result)

    def _handle_mdb_coin_changer_expansion_feature_enable(self, sequence, codec):
        # Read incoming parameters.
        feature_mask = codec.read_uint32()

        # Invoke user implementation of remote function.
        _result = self._handler.mdb_coin_changer_expansion_feature_enable(feature_mask)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_EXPANSION_FEATURE_ENABLE_ID,
            sequence=sequence))
        codec.write_int8(_result)

    def _handle_mdb_coin_changer_expansion_payout(self, sequence, codec):
        # Read incoming parameters.
        value = codec.read_uint8()

        # Invoke user implementation of remote function.
        _result = self._handler.mdb_coin_changer_expansion_payout(value)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_EXPANSION_PAYOUT_ID,
            sequence=sequence))
        codec.write_int8(_result)

    def _handle_mdb_coin_changer_expansion_payout_status(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        status = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.mdb_coin_changer_expansion_payout_status(status)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_EXPANSION_PAYOUT_STATUS_ID,
            sequence=sequence))
        if status.value is None:
            raise ValueError("status is None")
        for _i0 in status.value:
            codec.write_uint8(_i0)

        codec.write_int8(_result)

    def _handle_mdb_coin_changer_expansion_payout_poll(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        value = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.mdb_coin_changer_expansion_payout_poll(value)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_EXPANSION_PAYOUT_POLL_ID,
            sequence=sequence))
        if value.value is None:
            raise ValueError("value is None")
        codec.write_uint8(value.value)
        codec.write_int8(_result)

    def _handle_mdb_coin_changer_expansion_send_controlled_manual_fill_report(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        buf = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.mdb_coin_changer_expansion_send_controlled_manual_fill_report(buf)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_EXPANSION_SEND_CONTROLLED_MANUAL_FILL_REPORT_ID,
            sequence=sequence))
        if buf.value is None:
            raise ValueError("buf is None")
        for _i0 in buf.value:
            codec.write_uint8(_i0)

        codec.write_int8(_result)

    def _handle_mdb_coin_changer_expansion_send_controlled_manual_payout_report(self, sequence, codec):
        # Create reference objects to pass into handler for out/inout parameters.
        buf = erpc.Reference()

        # Read incoming parameters.

        # Invoke user implementation of remote function.
        _result = self._handler.mdb_coin_changer_expansion_send_controlled_manual_payout_report(buf)

        # Prepare codec for reply message.
        codec.reset()

        # Construct reply message.
        codec.start_write_message(erpc.codec.MessageInfo(
            type=erpc.codec.MessageType.kReplyMessage,
            service=interface.IMDB.SERVICE_ID,
            request=interface.IMDB.MDB_COIN_CHANGER_EXPANSION_SEND_CONTROLLED_MANUAL_PAYOUT_REPORT_ID,
            sequence=sequence))
        if buf.value is None:
            raise ValueError("buf is None")
        for _i0 in buf.value:
            codec.write_uint8(_i0)

        codec.write_int8(_result)


