Metadata-Version: 1.1
Name: unpythonic
Version: 0.10.2
Summary: Lispy (and some haskelly) missing batteries for Python.
Home-page: https://github.com/Technologicat/unpythonic
Author: Juha Jeronen
Author-email: juha.jeronen@tut.fi
License: BSD
Description: Python clearly wants to be an impure-FP language. A decorator with arguments
        is a curried closure - how much more FP can you get?
        
        We provide some missing features for Python from the list processing tradition,
        plus a few bonus haskellisms.
        
        We place a special emphasis on clear, pythonic syntax. Other design considerations
        are simplicity, robustness, and minimal dependencies (currently none).
        
        Features include tail call optimization (TCO), TCO'd loops in FP style, call/ec,
        let & letrec, assign-once, multi-expression lambdas, def as a code block,
        dynamic assignment, memoize (also for generators and iterables), compose,
        folds and scans (left and right), unfold, lazy partial unpacking of iterables,
        functional sequence updates, pythonic lispy linked lists.
        
        We provide a curry that passes extra arguments through on the right, and calls
        a callable return value on the remaining arguments. This is now valid Python::
        
            mymap = lambda f: curry(foldr, composerc(cons, f), nil)
            myadd = lambda a, b: a + b
            assert curry(mymap, myadd, ll(1, 2, 3), ll(2, 4, 6)) == ll(3, 6, 9)
        
        Finally, we provide a set of macros for those not afraid to install MacroPy
        and venture beyond raw Python. For example::
        
            # let, letseq, letrec with no boilerplate
            a = let((x, 17),
                    (y, 23))[
                      (x, y)]
        
            # cond: multi-branch "if" expression
            answer = lambda x: cond[x == 2, "two",
                                    x == 3, "three",
                                    "something else"]
            assert answer(42) == "something else"
        
            # do: imperative code in expression position
            y = do[localdef(x << 17),
                   print(x),
                   x << 23,
                   x]
            assert y == 23
        
            # autocurry like Haskell
            with curry:
                def add3(a, b, c):
                    return a + b + c
                assert add3(1)(2)(3) == 6
                # actually partial application so these work, too
                assert add3(1, 2)(3) == 6
                assert add3(1)(2, 3) == 6
                assert add3(1, 2, 3) == 6
        
                mymap = lambda f: foldr(composerc(cons, f), nil)
                myadd = lambda a, b: a + b
                assert mymap(myadd, ll(1, 2, 3), ll(2, 4, 6)) == ll(3, 6, 9)
        
            with tco:
                assert letrec((evenp, lambda x: (x == 0) or oddp(x - 1)),
                              (oddp,  lambda x: (x != 0) and evenp(x - 1)))[
                                evenp(10000)] is True
        
            # lambdas with multiple expressions, local variables, and a name
            with multilambda, namedlambda:
                myadd = lambda x, y: [print("myadding", x, y),
                                      localdef(tmp << x + y),
                                      print("result is", tmp),
                                      tmp]
                assert myadd(2, 3) == 5
                assert myadd.__name__ == "myadd (lambda)"
        
            # implicit "return" in tail position, like Lisps
            with autoreturn:
                def f():
                    print("hi")
                    "I'll just return this"
                assert f() == "I'll just return this"
        
                def g(x):
                    if x == 1:
                        "one"
                    elif x == 2:
                        "two"
                    else:
                        "something else"
                assert g(1) == "one"
                assert g(2) == "two"
                assert g(42) == "something else"
        
            # essentially call/cc for Python
            with continuations:
                stack = []
                def amb(lst, *, cc):  # McCarthy's amb operator
                    if not lst:
                        return fail()
                    first, *rest = lst
                    if rest:
                        ourcc = cc
                        stack.append(lambda *, cc: amb(rest, cc=ourcc))
                    return first
                def fail(*, cc):
                    if stack:
                        f = stack.pop()
                        return f()
        
                def pyth(*, cc):
                    with bind[amb(tuple(range(1, 21)))] as z:
                        with bind[amb(tuple(range(1, z+1)))] as y:
                            with bind[amb(tuple(range(1, y+1)))] as x:  # <-- the call/cc
                                if x*x + y*y != z*z:                    # body is the cont
                                    return fail()
                                return x, y, z
                x = pyth()
                while x:
                    print(x)
                    x = fail()
        
        For documentation and full examples, see the project's GitHub homepage.
        
Keywords: functional-programming,syntactic-macros,macros,lisp,scheme,racket,haskell
Platform: Linux
Classifier: Development Status :: 4 - Beta
Classifier: Environment :: Console
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: POSIX :: Linux
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.4
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Provides: unpythonic
