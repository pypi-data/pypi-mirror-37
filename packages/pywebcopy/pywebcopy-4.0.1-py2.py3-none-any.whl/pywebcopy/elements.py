# -*- coding: utf-8 -*-

"""
pywebcopy.elements
~~~~~~~~~~~~~~~~~~

Asset elements of a web page.

"""

import re
import sys
from os import path
from uuid import uuid4
from mimetypes import guess_extension
from pywebcopy import LOGGER
from pywebcopy.config import config
from pywebcopy.urls import Url, url2path
from pywebcopy.urls import filename_present
from pywebcopy import utils
from pywebcopy.urls import pathname2url
from pywebcopy.exceptions import InvalidUrlError
from pywebcopy.core import get
from pywebcopy.core import new_file

PY3 = (sys.version_info[0] == 3)
CSS_URLS = re.compile(b'''url\\(['|"]?(.*?)["|']?\\)''')


class FileMixin(Url):
    """Wrapper for every Asset type which is used by a web page. e.g. css, js.

     It inherits the Url() object to provide file path manipulations.
     """

    default_filename = str(uuid4())[:10] + '.download'

    def __init__(self, url):
        super(FileMixin, self).__init__(url)
        # this file needs to go in the project_folder to be able to correctly used by
        # the html file
        self.base_path = config['project_folder']

    def _save_file(self):
        """Saves the file from url and returns the file location. """

        # Pass the url to default downloader and will suppress and suppress any
        # error generated by the downloader
        new_file(content_url=self.url, location=self.file_path)
        LOGGER.info("Saved the file successfully to the location %s" % self.file_path)

    def save_file(self):
        """Saves the file in background thread."""
        self._save_file()


class Asset(FileMixin):
    """Wrapper for unknown Asset types which is used for unknown url types
    which are automatically detected and saved."""

    def __init__(self, url):
        self.req = None
        super(Asset, self).__init__(url)

    def _request(self):
        """Returns HTTP request object."""

        self.req = get(self.url, stream=True)

        if not self.req or not self.req.ok:
            LOGGER.error("Server returned error for the url %s" % self.url)
            raise InvalidUrlError("Server returned error for the url %s" % self.url)
        return self.req

    def _contentType(self):
        """Return the content-type as seen on request headers or a default type."""
        return self.req.headers.get('content-type') if self.req else ''

    def _fnCheck(self):
        """Checks if filename is present, if not then generate a default one."""
        # A default filename is generated based on url in case the file path doesn't have
        # a filename could create errors when writing files.
        if not filename_present(self.url):
            # we will get the mime-type of this file and try to guess the file extension
            # then we will create a random filename with the guessed file extension
            # which will not create an error during saving of the file

            _guess_ext = guess_extension(self._contentType(), strict=False) or '.download'
            _filename = str(uuid4()) + _guess_ext
            self.default_filename = _filename

    def save_file(self):
        """Saves this file after detection of type and generating a suitable default filename."""

        req = self._request()

        # now since a default filename is set then we will move to saving this file
        path = new_file(content=req.content or b"File couldn't be downloaded!.", location=self.file_path)
        LOGGER.info("Saved the file successfully to the location %s" % path)
        return path


class AnchorTag(FileMixin):
    """Customises the FileMixin() object for Anchor Tags"""

    default_filename = "index.html"

    def __init__(self, url):

        super(AnchorTag, self).__init__(url)

    def save_file(self):
        pass


class LinkTag(FileMixin):
    """Customises the FileMixin() object for css file type."""

    def __init__(self, url):
        
        # Random 50 chars long file name
        self.default_filename = "%s.css" % str(uuid4())[:15]

        super(LinkTag, self).__init__(url)


    @staticmethod
    def extract_css_urls(url_obj, contents=None):
        """
        Extracts url() links in css and saves and
        replaces them in file
        all the linked file url() will be saved and file path
        would be replaced accordingly

        """

        if not contents:
            try:
                # read the file
                LOGGER.debug('Reading Existing file at %s' % url_obj.file_path)
                contents = open(url_obj.file_path, 'rb').read()
                LOGGER.debug('Finding CSS urls in file %s' % url_obj.file_path)

            except Exception as e:
                LOGGER.critical(e)
                LOGGER.critical('Failed to open file %s for CSS urls search' % url_obj.file_path)
                return

        # the regex matches all those with double mix-match quotes and normal ones
        # also have to strip down the mix match quotes
        _urls = CSS_URLS.findall(contents)

        # if links are not found
        if len(_urls) == 0:
            LOGGER.info('No CSS linked files are found in file %s' % url_obj.file_path)
            return contents

        # links are found, now extract and save them
        LOGGER.info('%d CSS linked files are found in file %s' % (len(_urls), url_obj.file_path))

        for _url in _urls:
            # Urls may have double unequal quotes which is due to re pattern limitation
            # urls are in bytes format which creates error when doing url operations
            # thus have to be suppressed
            try:
                _str_url = _url.encode('utf8')
            except Exception as e:
                LOGGER.debug(e)
                LOGGER.debug("Conversion to unicode failed for the url %r" % _url)
                continue

            # url can be base64 encoded content which is not required to be stored
            if _str_url[:4] == 'data':
                continue

            try:
                # a path is generated by the cssAsset object and tried to store the file
                # but file could be corrupted to open or write
                _obj = Asset(_str_url)
                _obj.base_url = url_obj.url
                _obj.base_path = config['project_folder']
                _obj.save_file()

            except Exception as e:
                LOGGER.error(e)
                LOGGER.error("Error while searching CSS file! A File failed to be Saved of url %s" % _str_url)
                continue

            # generate a relative path for this downloaded file
            _rel_url = pathname2url(utils.relate(
                _obj.file_path, url_obj.file_path
            ))
            LOGGER.debug('Replacing linked file path %s by %s' % (_str_url, _rel_url))

            # save the location of the downloaded file on the original file
            if sys.version_info[0] == 3:
                # reconvert to bytes
                _rel_url = bytes(_rel_url, "utf-8")
                contents = contents.replace(_url, _rel_url)
            else:
                _rel_url = bytes(_rel_url)
                contents = contents.replace(_url, _rel_url)

        if not contents:
            # if the search was in a pre-existing file then
            # rewrite the original file to contain the newly downloaded file links
            with open(url_obj.file_path, 'wb') as orig_file:
                orig_file.write(contents)

        else:
            # otherwise return the rewritten bytes contents
            return contents

    def save_file(self):
        """Css files are saved differently because they could have url() files in them which also links
        for different files. Thus css file content needs to be searched for urls and then it will proceed
        as usual."""

        # LinkTags can also be specified for elements like favicon etc. Thus a check is neccessary
        # to validate it is a proper css file or not.
        if not self.file_name.endswith('.css'):
            super(LinkTag, self).save_file()

        # Custom request object creation
        req = get(self.url)

        # if some error occurs
        if not req or not req.ok:
            raise InvalidUrlError("Url returned an unknown response %s" % self.url)

        # Send the contents for urls
        content = self.extract_css_urls(contents=req.content.decode(req.encoding), url_obj=self)

        # Save the content peacefully
        new_file(location=self.file_path, content=content.encode('iso-8859-1', errors='ignore'))


class ScriptTag(FileMixin):
    """Customises the Asset() object for css file type."""

    def __init__(self, url):
        # Random 50 chars long file name
        self.default_filename = "%s.js" % str(uuid4())[:15]
        super(ScriptTag, self).__init__(url)



class ImgTag(FileMixin):
    """Customises the Asset() object for images file type."""

    def __init__(self, url):
        # Random 50 chars long file name
        self.default_filename = "%s.jpg" % str(uuid4())
        super(ImgTag, self).__init__(url)



